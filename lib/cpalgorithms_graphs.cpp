#include <bits/stdc++.h>
using namespace std;
typedef uint64_t ull;
typedef int64_t  ll;
const ll infll = 9223372036854775807LL;
#define PB push_back  
#define MP make_pair  
#define SZ(v) ((ll)(v).size())  
#define FOR(i,a,b) for(ll i=(a);i<(b);++i)  
#define REP(i,n) FOR(i,0,n)  
#define FORE(i,a,b) for(ll i=(a);i<=(b);++i)  
#define REPE(i,n) FORE(i,0,n)  
#define FORSZ(i,a,v) FOR(i,a,SZ(v))  
#define REPSZ(i,v) REP(i,SZ(v))

//////////////////////////////////////////////////
//
// SECTION A: GRAPH TRAVERSAL
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION A1: Breadth First Search
// https://cp-algorithms.com/graph/breadth-first-search.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION A2: Depth First Search
// https://cp-algorithms.com/graph/depth-first-search.html
////////////////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// SECTION B: CONNECTED COMPONENTS, BRIDGES, ARTICULATION POINTS
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION B1: Finding Connected Components
// https://cp-algorithms.com/graph/search-for-connected-components.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION B2: Finding Bridges in O(N+M) 
// https://cp-algorithms.com/graph/bridge-searching.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION B3: Finding Bridges Online
// https://cp-algorithms.com/graph/bridge-searching-online.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION B4: Finding Articulation Points in O(N+M)
// https://cp-algorithms.com/graph/cutpoints.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION B5: Strongly Connected Components and Condensation Graph
// https://cp-algorithms.com/graph/strongly-connected-components.html
////////////////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// SECTION C: SINGLE_SOURCE SHORTEST PATHS
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION C1: Dijkstra - finding shortest paths from given vertex
// https://cp-algorithms.com/graph/dijkstra.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION C2: Dijkstra on sparse graphs
// https://cp-algorithms.com/graph/dijkstra_sparse.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION C3: Bellman-Ford - finding shortest paths with negative weights
// https://cp-algorithms.com/graph/bellman_ford.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION C4: 0-1 BFS
// https://cp-algorithms.com/graph/01_bfs.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION C5: D'Esopo-Pape Algorithm
// https://cp-algorithms.com/graph/desopo_pape.html
////////////////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// SECTION D: ALL-PAIRS SHORTEST PATHS
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION D1: Floyd-Warshall - finding all shortest paths
// https://cp-algorithms.com/graph/all-pair-shortest-path-floyd-warshall.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION D2: Number of paths of fixed length / Shortest paths of fixed length
// https://cp-algorithms.com/graph/fixed_length_paths.html
////////////////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// SECTION E: SPANNING TREES
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION E1: Minimum Spanning Tree -- Prim's Algorithm
// https://cp-algorithms.com/graph/mst_prim.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION E2: Minimum Spanning Tree -- Kruskal
// https://cp-algorithms.com/graph/mst_kruskal.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION E3: Minimum Spanning Tree -- Kruskal with Disjoint Set Union
// https://cp-algorithms.com/graph/mst_kruskal_with_dsu.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION E4: Second best Minimum Spanning Tree -- Using Kruskal and Lowest Common Ancestor
// https://cp-algorithms.com/graph/second_best_mst.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION E5: Kirchhoff Theorem
// https://cp-algorithms.com/graph/kirchhoff-theorem.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION E6: Prufer code
// https://cp-algorithms.com/graph/pruefer_code.html
////////////////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// SECTION F: CYCLES
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION F1: Checking a graph for acyclicity and finding a cycle in O(M)
// https://cp-algorithms.com/graph/finding-cycle.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION F2: Finding a Negative Cycle in the Graph
// https://cp-algorithms.com/graph/finding-negative-cycle-in-graph.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION F3: Eulerian Path
// https://cp-algorithms.com/graph/euler_path.html
////////////////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// SECTION G: LOWEST COMMON ANCESTOR
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION G1: Lowest Common Ancestor
// https://cp-algorithms.com/graph/lca.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION G2: Lowest Common Ancestor - Binary Lifting
// https://cp-algorithms.com/graph/lca_binary_lifting.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION G3: Lowest Common Ancestor - Farach-Colton and Bender algorithm
// https://cp-algorithms.com/graph/lca_farachcoltonbender.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION G4: Solve RMQ by finding LCA
// https://cp-algorithms.com/graph/rmq_linear.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION G5: Lowest Common Ancestor -- Tarjan's off-line algorithm
// https://cp-algorithms.com/graph/lca_tarjan.html
////////////////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// SECTION H: FLOWS AND RELATED PROBLEMS
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION H1: Maximum flow - Ford-Fulkerson and Edmonds-Karp
// https://cp-algorithms.com/graph/edmonds_karp.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION H2: Maximum flow - Push-relabel algorithm
// https://cp-algorithms.com/graph/push-relabel.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION H3: Maximum flow - Push-relabel algorithm improved
// https://cp-algorithms.com/graph/push-relabel-faster.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION H4: Dinic's algorithm
// https://cp-algorithms.com/graph/dinic.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION H5: MPM algorithm
// https://cp-algorithms.com/graph/mpm.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION H6: Flows with Demands
// https://cp-algorithms.com/graph/flow_with_demands.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION H7: Minmum-cost flow
// https://cp-algorithms.com/graph/min_cost_flow.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION H8: Assignment problem.  Solution using min-cost-flow in O(N^5)
// https://cp-algorithms.com/graph/Assignment-problem-min-flow.html
////////////////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// SECTION I: MATCHINGS AND RELATED PROBLEMS
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION I1: Bipartite Graph Check
// https://cp-algorithms.com/graph/bipartite-check.html
////////////////////////////////////////////////////////////

//////////////////////////////////////////////////
//
// SECTION J: Miscellaneous
//
//////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION J1: Topological Sorting
// https://cp-algorithms.com/graph/topological-sort.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION J2: Edge connectivity / Vertex connectivity
// https://cp-algorithms.com/graph/edge_vertex_connectivity.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION J3: Tree painting
// https://cp-algorithms.com/graph/tree_painting.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION J4: 2-SAT
// https://cp-algorithms.com/graph/2SAT.html
////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////
// SUBSECTION J5: Heavy-light decomposition
// https://cp-algorithms.com/graph/hld.html
////////////////////////////////////////////////////////////


int main() {
    ios::sync_with_stdio(false);
    cin.tie(0); cout.tie(0);
    cout << fixed << setprecision(15);
    //freopen("999A.in1","r",stdin);
    return 0;
}
